#!/usr/bin/env python3

"""Run reptar calculations"""

from collections.abc import Iterable
import argparse
import time
import datetime
import os
import yaml
from reptar import File
from reptar.calculators import Data, Driver
from reptar.calculators.utils import prep_xtb_input_lines
from reptar.utils import get_obj_from_string
from reptar.logger import ReptarLogger, set_log_level

log = ReptarLogger(__name__)


def parse_args():
    parser = argparse.ArgumentParser(description="Run calculations using reptar")
    parser.add_argument(
        "config_path",
        type=str,
        nargs="?",
        help="Path to YAML configuration file",
    )
    parser.add_argument(
        "--ray_address",
        type=str,
        nargs="?",
        default="",
        help="Desired ray address (will override config file)",
    )
    parser.add_argument(
        "--log_level",
        type=str,
        nargs="?",
        default="info",
        help="Desired logging level",
    )
    return parser.parse_args()


def _load_config(config_path):
    log.info("Loading config.yaml")
    with open(config_path, "r", encoding="utf-8") as stream:
        config = yaml.safe_load(stream)
    return config


def _process_worker_kwargs(
    tasks: Iterable[str],
    config: dict[str, "Any"],
    worker_name: str,
):
    r"""Prepare worker keyword arguments as they are dependent on task and worker.

    Parameters
    ----------
    tasks
        Requested computations.
    config
        Configuration file.
    worker_name
        Function name to identify the worker.
    """
    worker_kwargs = config["worker"]["kwargs"]

    # Handling worker arguments
    if "opt" in tasks:
        if worker_name == "xtb_worker":
            opt_block = config["worker"]["blocks"].get("opt", None)
            constraints = config["worker"].get("constrain", None)
            input_lines = prep_xtb_input_lines(
                charge=config["system"]["charge"],
                multiplicity=config["system"]["multiplicity"],
                opt_block=opt_block,
                constraints=constraints,
                save_traj=False,
            )
            worker_kwargs["input_lines"] = input_lines

    return worker_kwargs


def main(args):
    config = _load_config(args.config_path)

    log.info("Opening file")
    rfile_path = os.path.abspath(config["rfile"]["path"])
    rfile = File(rfile_path, mode="a")

    log.info("Preparing data for calculations")
    # Getting rfile information
    tasks = config["tasks"]

    source_key = config["rfile"]["source"]["key"]
    source_labels = config["rfile"]["source"]["labels"]
    dest_key = config["rfile"]["destination"]["key"]
    dest_labels = config["rfile"]["destination"]["labels"]

    data = Data()
    data.rfile = rfile
    data.prepare_tasks(tasks, source_key, source_labels, dest_key, dest_labels)

    driver_kwargs = config["driver"]["kwargs"]
    if args.ray_address != "":
        driver_kwargs["ray_address"] = args.ray_address
    driver = Driver(**driver_kwargs)
    start_slice = config["driver"]["start_slice"]
    end_slice = config["driver"]["end_slice"]

    worker_obj = get_obj_from_string(config["worker"]["path"])
    worker_name = worker_obj.__name__
    log.info("Selected worker: %s", worker_name)
    worker_kwargs = _process_worker_kwargs(tasks, config, worker_name)

    log.info("Requested tasks: %s", ", ".join(tasks))

    n_todo = data.get_idxs_todo(tasks, start_slice, end_slice).shape[0]
    log.info("Running %r calculations", n_todo)

    if n_todo > 0:
        t_start = time.perf_counter()
        driver.run(worker_obj, worker_kwargs, data, tasks, start_slice, end_slice)
        log.info("Calculations are done")
        t_end = time.perf_counter()
        duration = str(datetime.timedelta(seconds=t_end - t_start))
        log.info("Finished in %s", duration)
    else:
        log.warning("Check your bounds if you are selecting a subset of structures")

    n_remaining = data.get_idxs_todo(tasks, start_slice, end_slice).shape[0]
    log.info("There are %r incomplete calculations remaining", n_remaining)


if __name__ == "__main__":
    parsed_args = parse_args()
    set_log_level(parsed_args.log_level.upper())
    main(parsed_args)
